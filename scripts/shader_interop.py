#! /usr/bin/env python3
import re
import sys
from dataclasses import dataclass
import shader_structs
from shader_structs import Struct
import shader_uniforms

# TODO: keep comments
COMMENTS: re.Pattern = re.compile(r"//.*$", re.MULTILINE)


def remove_comments(file_contents: str) -> str:
    return re.sub(COMMENTS, "", file_contents)


FIND_STRUCT: re.Pattern = re.compile(r"struct \S+ {.*?};", re.DOTALL)


def find_structs(file_contents: str) -> list[str]:
    return re.findall(FIND_STRUCT, file_contents)


@dataclass
class ParsedFile:
    struct_code: list[tuple[Struct, str]]  # maps structs to their corresponding code


def process_file(file_contents: str) -> ParsedFile:
    file_contents = remove_comments(file_contents)
    structs: list[str] = find_structs(file_contents)

    struct_table: dict[str, Struct] = {}
    output = ParsedFile([])
    for struct in structs:
        struct_inst, struct_code = shader_structs.process_struct(struct, struct_table)
        output.struct_code.append((struct_table[struct_inst.name], struct_code))

    return output


SHADER_NAME: re.Pattern = re.compile(r"(.*?)(\.glsl)?$")


def shader_name(file_path: str) -> str:
    filename: str = file_path.split("/")[-1]
    name_match: re.Match | None = re.match(SHADER_NAME, filename)
    if name_match is not None:
        name: str = name_match.group(1)
    else:
        raise Exception(f"Invalid filename for shader {file_path}")
    name = name.replace(".", "_") # can't have dots in namespaces
    return name


def header(namespace: str) -> str:
    return (f"\n// this file autogenerated by {sys.argv[0]}\n"
             "#pragma once\n"
             "#include <glm/glm.hpp>\n"
             "#include \"../../src/shaders/shaderCommon.hpp\"\n\n"
            f"namespace {namespace} {{\n"
    )


def footer() -> str:
    return "\n}\n\n"


PASCAL_CASE: re.Pattern = re.compile(r"(?<!^)(?<=[a-z])(?=[A-Z])")


# generates the final C++ program
def link_shader(files: list[ParsedFile], class_def: str) -> str:
    # exact duplicates are fine
    # the tuple contains struct name and struct code
    joined_list: list[tuple[Struct, str]] = []
    for parsed_file in files:
        for entry in parsed_file.struct_code:
            # check against all existing entries for duplicates
            is_duplicate = False
            for existing_entry in joined_list:
                if entry[0].name == existing_entry[0].name:
                    if entry[1] != existing_entry[1]:
                        # names match but contents do not
                        # grab only the struct definition, nothing else
                        entry_def: str = entry[1].split("\n\n")[0]
                        existing_def: str = existing_entry[1].split("\n\n")[0]
                        raise Exception(f"Differing definitions of struct {entry[0].name}:\n===============\n{entry_def}\n===== and =====\n{existing_def}\n===============")
                    is_duplicate = True  # must be an exact duplicate, but still don't re add
            if not is_duplicate:
                joined_list.append(entry)

    output: str = ""
    namespace: str = "Shaders"
    output += header(namespace)

    for file in joined_list:

        # so that different definitions in different files are caught
        define_name: str = "STRUCT_HASH_" + re.sub(PASCAL_CASE, "_", file[0].name).upper()
        struct_hash: int = hash(file[1])
        output += f"\n#ifndef {define_name}\n"
        output +=   file[1]
        output +=   f"\n#define {define_name} {struct_hash}\n"
        output +=  "#else\n"
        output +=   f"#if {define_name} != {struct_hash}\n"
        output +=     f"#error \"Conflicting definitions of struct {file[0].name}\"\n"
        output +=    "#endif\n"
        output +=  "#endif\n"

    output += "\n" + class_def + "\n"

    output += footer()
    return output


if __name__ == "__main__":
    parsed_files: list[ParsedFile] = []
    input_filenames: list[str] = sys.argv[1:-1]
    file_contents: str = ""

    for i in input_filenames:
        with open(i, 'r') as input_file:
            input_str: str = input_file.read()
            file_contents += "\n" + input_str
            parsed_files.append(process_file(input_str))

    # flatten everything into a simple list of structs
    just_structs: list[Struct] = []
    for file in parsed_files:
        for this_tuple in file.struct_code:
            just_structs.append(this_tuple[0])

    class_def: str = shader_uniforms.generate_class(file_contents, input_filenames, just_structs)

    output: str = link_shader(parsed_files, class_def)

    with open(sys.argv[-1], "w+") as output_file:
        output_file.write(output)

