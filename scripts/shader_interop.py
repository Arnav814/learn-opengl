#! /usr/bin/env python3
import re
import sys
from dataclasses import dataclass
import shader_structs
from shader_structs import Struct
import shader_uniforms

# TODO: keep comments
COMMENTS: re.Pattern = re.compile(r"//.*$", re.MULTILINE)

def remove_comments(file_contents: str) -> str:
    return re.sub(COMMENTS, "", file_contents)

FIND_STRUCT: re.Pattern = re.compile(r"struct \S+ {.*?};", re.DOTALL)

def find_structs(file_contents: str) -> list[str]:
    return re.findall(FIND_STRUCT, file_contents)

@dataclass
class ParsedFile:
    struct_code: list[tuple[str, str]] # maps structs to their corresponding code

def process_file(file_contents: str) -> ParsedFile:
    file_contents = remove_comments(file_contents)
    structs: list[str] = find_structs(file_contents)

    struct_table: dict[str, Struct] = {}
    output = ParsedFile([])
    for struct in structs:
        struct_name, struct_code = \
            shader_structs.process_struct(struct, struct_table)
        output.struct_code.append((struct_name, struct_code))

    return output

SHADER_NAME: re.Pattern = re.compile(r"(.*?)(\.glsl)?$")

def shader_name(file_path: str) -> str:
    filename: str = file_path.split("/")[-1]
    name_match: re.Match | None = re.match(SHADER_NAME, filename)
    if name_match is not None:
        name: str = name_match.group(1)
    else:
        raise Exception(f"Invalid filename for shader {file_path}")
    name = name.replace(".", "_") # can't have dots in namespaces
    return name

def header(namespace: str) -> str:
    return (f"\n// this file autogenerated by {sys.argv[0]}\n"
             "#pragma once\n"
             "#include <glm/glm.hpp>\n"
             "#include \"../../src/shaders/shaderCommon.hpp\"\n\n"
            f"namespace {namespace} {{\n"
           )

def footer() -> str:
    return "\n}\n\n"

PASCAL_CASE: re.Pattern = re.compile(r"(?<!^)(?<=[a-z])(?=[A-Z])")

# generates the final C++ program
def link_shader(files: list[ParsedFile]) -> str:
    # exact duplicates are fine
    # the tuple contains struct name and struct code
    joined_defs: set[tuple[str, str]] = set()
    for elem in files:
        joined_defs |= set(elem.struct_code)

    joined_list = list(joined_defs)
    for file_index, file in enumerate(joined_list):
        for next_file in joined_list[file_index + 1:]:
            if file[0] == next_file[0]: # names are the same, definitions are not
                raise Exception(f"Differing definitions of struct {file[0]}: \"{file[1]}\" and \"{next_file[1]}\"")

    output: str = ""
    namespace: str = "Shaders"
    output += header(namespace)

    for file in joined_list:

        # so that different definitions in different files are caught
        define_name: str = "STRUCT_HASH_" + re.sub(PASCAL_CASE, "_", file[0]).upper()
        struct_hash: int = hash(file[1])
        output += f"\n#ifndef {define_name}\n"
        output +=   file[1]
        output +=   f"\n#define {define_name} {struct_hash}\n"
        output +=  "#else\n"
        output +=   f"#if {define_name} != {struct_hash}\n"
        output +=     f"#error \"Conflicting definitiions of struct {file[0]}\"\n"
        output +=    "#endif\n"
        output +=  "#endif\n"

    output += footer()
    return output

if __name__ == "__main__":
    parsed_files: list[ParsedFile] = []
    for i in sys.argv[1:-1]:
        with open(i, 'r') as input_file:
            input_str: str = input_file.read()
            parsed_files.append(process_file(input_str))

    output: str = link_shader(parsed_files)

    with open(sys.argv[-1], "w+") as output_file:
        output_file.write(output)

